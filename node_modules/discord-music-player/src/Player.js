const ytdl = require('ytdl-core');
const mergeOptions = require('merge-options');
const ytsr = require('ytsr');
const { VoiceChannel, version, User, Snowflake } = require("discord.js");
if (Number(version.split('.')[0]) < 12) throw new Error("Only the master branch of discord.js library is supported for now. Install it using 'npm install discordjs/discord.js'.");
const Queue = require('./Queue');
const Util = require('./Util');
const Song = require('./Song');
const Playlist = require('./Playlist');
const MusicPlayerError = require('./MusicPlayerError');
let playingMessageStack = [];
/**
 * Player options.
 * @typedef {PlayerOptions}
 * 
 * @property {Boolean} leaveOnEnd Whether the bot should leave the current voice channel when the queue ends.
 * @property {Boolean} leaveOnStop Whether the bot should leave the current voice channel when the stop() function is used.
 * @property {Boolean} leaveOnEmpty Whether the bot should leave the voice channel if there is no more member in it.
 * @property {Milliseconds} timeout After how much time the bot should leave the voice channel after the OnEnd & OnEmpty events. | Default: 0
 * @property {string} quality Music quality ['high'/'low'] | Default: high
 */
const PlayerOptions = {
    leaveOnEnd: true,
    leaveOnStop: true,
    leaveOnEmpty: true,
    timeout: 0,
    quality: 'low'
};

class Player {

    /**
     * @param {Client} client Your Discord Client instance.
     * @param {PlayerOptions} options The PlayerOptions object.
     */
    constructor(client, options = {}) {
        if (!client) throw new SyntaxError('[Discord_Client_Invalid] Invalid Discord Client');
        if (!options || typeof options != 'object') throw new SyntaxError('[Options is not an Object] The Player constructor was updated in v5.0.2, please use: new Player(client, { options }) instead of new Player(client, token, { options })');
        if (typeof options.timeout != 'undefined' && (isNaN(options.timeout) || !isFinite(options.timeout))) throw new TypeError('[TimeoutInvalidType] Timeout should be a Number presenting a value in milliseconds.');
        if (typeof options.volume != 'undefined' && (isNaN(options.volume) || !isFinite(options.volume))) throw new TypeError('[VolumeInvalidType] Volume should be a Number presenting a value in percentual.');

        /**
         * Your Discord Client instance.
         * @type {Client}
         */
        this.client = client;
        /**
         * The guilds data.
         * @type {Queue[]}
         */
        this.queues = [];
        /**
         * Player options.
         * @type {PlayerOptions}
         */
        this.options = mergeOptions(PlayerOptions, options);
        /**
         * ytsr
         * @type {Function || ytsr}
         */
        this.ytsr = ytsr;

        /**
         * song numer
         */
        this.songNum = 0;

        // Listener to check if the channel is empty
        client.on('voiceStateUpdate', (oldState, newState) => {
            const Discord = require('discord.js');
            const guild = this.client.guilds.cache.get(oldState.guild.id);
            const id = JSON.parse(localStorage.getItem('textChannelID'));
            const TextChannel = guild.channels.cache.get(id);
            
            if (!this.options.leaveOnEmpty) return;
            // If message leaves the current voice channel
            if (oldState.channelID === newState.channelID) return;
            // Search for a queue for this channel
            let queue = this.getQueue(oldState.guild.id);
            if (queue) {
                // If the channel is not empty
                if (queue.connection.channel.members.size > 1) return;
                // Start timeout

                setTimeout(() => {
                    // If the channel is not empty
                    if (queue.connection.channel.members.size > 1) return;
                    // Disconnect from the voice channel
                    queue.connection.channel.leave();
                    queue.connection.channel.members.map(member => {
                        if (member.user.bot) {
                            try { TextChannel.send(new Discord.MessageEmbed().setDescription('Voice channel is empty, now leaving the voice channel.')); } catch {}
                        }
                    })
                    // Delete the queue
                    this.queues = this.queues.filter((g) => g.guildID !== queue.guildID);
                    // Emit end event
                    queue.emit('channelEmpty');
                }, this.options.timeout);
            }
        });
    }

    /**
     * Whether a guild is currently playing songs
     * @param {string} guildID The guild ID to check
     * @returns {Boolean} Whether the guild is currently playing songs
     */
    isPlaying(guildID) {
        return this.queues.some((g) => g.guildID === guildID);
    }

    /**
     * Plays a song in a voice channel.
     * @param {VoiceChannel} voiceChannel The voice channel in which the song will be played.
     * @param {string} songName The name of the song to play.
     * @param {object} options Search options.
     * @param {User} requestedBy The user who requested the song.
     * @returns {Promise<Song>}
     */
    async play(voiceChannel, songName, options = {}, requestedBy) {
        let _connection = await voiceChannel.join();
        this.queues = this.queues.filter((g) => g.guildID !== voiceChannel.id);
        if (voiceChannel ? voiceChannel.type !== 'voice' : true) return new MusicPlayerError('VoiceChannelTypeInvalid', 'song');
        if (typeof songName !== 'string' || songName.length === 0) return new MusicPlayerError('SongTypeInvalid', 'song');
        if (typeof options !== 'object') return new MusicPlayerError('OptionsTypeInvalid', 'song');
        try {
            // Creates a new guild with data
            let queue = new Queue(voiceChannel.guild.id, this.options);
            // Searches the song
            let song = await Util.getVideoBySearch(songName, options, queue, requestedBy);
            // Joins the voice channel
            queue.connection = _connection;
            queue.songs.push(song);
            // Add the queue to the list
            this.queues.push(queue);
            // Plays the song
            await this._playSong(queue.guildID, true);

            return { error: null, song: song };
        }
        catch (err) {
            console.log(err)
            return new MusicPlayerError(err === 'InvalidSpotify' ? err : 'SearchIsNull', 'song');
        }
    }

    /**
     * Seeks the current playing song.
     * @param {String} guildID Guild ID.
     * @param {Number} seek Seek (in milliseconds) time.
     * @returns {Promise<{Song} || MusicPlayerError>}
     */
    async seek(guildID, seek) {
        if(isNaN(seek)) return new MusicPlayerError('NotANumber', 'song');
        let queue = this.getQueue(guildID);
        if (!queue) return new MusicPlayerError('QueueIsNull', 'song');

        queue.songs[this.songNum].seekTime = seek;
        await this._playSong(guildID, true, seek);
        return { error: null, song: queue.songs[this.songNum] };
    }

    /**
     * Plays or adds the Playlist songs to the queue.
     * @param {String} guildID
     * @param {String} playlistLink The name of the song to play.
     * @param {VoiceChannel} voiceChannel The voice channel in which the song will be played.
     * @param {Number} maxSongs Max songs to add to the queue.
     * @param {String} requestedBy The user who requested the song.
     * @returns {Promise<{song: (null|Song), playlist: Playlist} || MusicPlayerError>}
     */
    async playlist(guildID, playlistLink, voiceChannel, maxSongs, requestedBy) {
        let queue = this.getQueue(guildID);
        try {maxSongs -= queue.songs.length;} catch {}
        if (!queue) if (voiceChannel ? voiceChannel.type !== 'voice' : true) return new MusicPlayerError('VoiceChannelTypeInvalid', 'song', 'playlist');
        if (typeof playlistLink !== 'string' || playlistLink.length === 0) return new MusicPlayerError('PlaylistTypeInvalid', 'song', 'playlist');
        if (typeof maxSongs !== 'number') return new MusicPlayerError('MaxSongsTypeInvalid', 'song', 'playlist');

        try {
            let connection = queue ? queue.connection : null
            let isFirstPlay = !!queue;
            if (!queue) {
                // Joins the voice channel if needed
                connection = await voiceChannel.join();
                // Creates a new guild with data if needed
                queue = new Queue(voiceChannel.guild.id, this.options);
                queue.connection = connection;
            }
            // Searches the playlist
            let playlist = await Util.getVideoFromPlaylist(playlistLink, maxSongs, queue, requestedBy);
            // Add all songs to the GuildQueue
            queue.songs = queue.songs.concat(playlist.videos);
            // Updates the queue
            this.queues.push(queue);
            // Plays the song

            if (!isFirstPlay)
                await this._playSong(queue.guildID, !isFirstPlay);

            return {
                error: null,
                song: isFirstPlay ? null : queue.songs[this.songNum],
                playlist
            };
        }
        catch (err) {
            return new MusicPlayerError('InvalidPlaylist', 'song', 'playlist');
        }
    }


    /**
     * Pauses the current song.
     * @param {string} guildID
     * @returns {Song}
     */
    pause(guildID) {
        // Gets guild queue
        let queue = this.queues.find((g) => g.guildID === guildID);
        if (!queue) return new MusicPlayerError('QueueIsNull');
        // Pauses the dispatcher
        queue.dispatcher.pause();
        queue.playing = false;
        // Resolves the guild queue
        return queue.songs[this.songNum];
    }

    /**
     * Resumes the current song.
     * @param {string} guildID
     * @returns {Song}
     */
    resume(guildID) {
        // Gets guild queue
        let queue = this.queues.find((g) => g.guildID === guildID);
        if (!queue) return new MusicPlayerError('QueueIsNull');
        // Resumes the dispatcher
        queue.dispatcher.resume();
        queue.dispatcher.pause();
        queue.dispatcher.resume();
        queue.playing = true;
        // Resolves the guild queue
        return queue.songs[this.songNum];
    }

    /**
     * Stops playing music.
     * @param {string} guildID
     * @returns {Void}
     */
    stop(guildID) {
        // Gets guild queue
        let queue = this.queues.find((g) => g.guildID === guildID);
        if (!queue) return new MusicPlayerError('QueueIsNull');
        // Stops the dispatcher
        queue.stopped = true;
        queue.songs = [];
        queue.dispatcher.end();
        queue.connection.channel.leave();
        // Resolves
        return;
    }

    /**
     * Updates the volume.
     * @param {string} guildID 
     * @param {number} percent 
     * @returns {Void}
     */
    setVolume(guildID, percent) {
        // Gets guild queue
        let queue = this.queues.find((g) => g.guildID === guildID);
        if (!queue) return new MusicPlayerError('QueueIsNull');
        // Updates volume
        queue.dispatcher.setVolumeLogarithmic(percent/200);
        // Resolves guild queue
        return;
    }

    /**
     * Gets the guild queue.
     * @param {string} guildID
     * @returns {?Queue}
     */
    getQueue(guildID) {
        // Gets guild queue
        let queue = this.queues.find((g) => g.guildID === guildID);
        return queue;
    }

    /**
     * Adds a song to the guild queue.
     * @param {string} guildID
     * @param {string} songName The name of the song to add to the queue.
     * @param {User} requestedBy The user who requested the song.
     * @returns {Promise<Song>}
     */
    /**
     * Adds a song to the guild queue.
     * @param {String} guildID Guild ID.
     * @param {String} songName The name of the song to add to the queue.
     * @param {Object} options Search options.
     * @param {String} requestedBy The user who requested the song.
     * @returns {Promise<{Song} || MusicPlayerError>}
     */
    async addToQueue(guildID, songName, options = {}, requestedBy) {
        // Gets guild queue
        let queue = this.getQueue(guildID);
        if (!queue) return new MusicPlayerError('QueueIsNull', 'song');
        if (typeof songName !== 'string' || songName.length === 0) return new MusicPlayerError('SongTypeInvalid', 'song');
        if (typeof options !== 'object') return new MusicPlayerError('OptionsTypeInvalid', 'song');
        try {
            // Searches the song
            let song = await Util.getVideoBySearch(songName, options, queue, requestedBy);
            if(song.duration === null) return;
            // Updates the queue
            queue.songs.push(song);
            // Resolves the song
            return { error: null, song: song };
        }
        catch (err) {
            return new MusicPlayerError(err === 'InvalidSpotify' ? err : 'SearchIsNull', 'song');
        }
    }

    /**
     * Sets the queue for a guild.
     * @param {string} guildID
     * @param {Array<Song>} songs The songs list
     * @returns {Queue}
     */
    setQueue(guildID, songs) {
        // Gets guild queue
        let queue = this.queues.find((g) => g.guildID === guildID);
        if (!queue) return new MusicPlayerError('QueueIsNull');
        // Updates queue
        queue.songs = songs;
        // Resolves the queue
        return queue.songs;
    }

    /**
     * Clears the guild queue, but not the current song.
     * @param {string} guildID
     * @returns {Queue}
     */
    clearQueue(guildID) {
        // Gets guild queue
        let queue = this.queues.find((g) => g.guildID === guildID);
        if (!queue) return new MusicPlayerError('QueueIsNull');
        // Clears queue
        let currentlyPlaying = queue.songs[this.songNum];
        queue.songs = [currentlyPlaying];
        // Resolves guild queue
        return queue.songs;
    }

    /**
     * Skips a song.
     * @param {string} guildID
     * @returns {Song}
     */
    skip(guildID) {
        // Gets guild queue
        let queue = this.queues.find((g) => g.guildID === guildID);
        if (!queue) return new MusicPlayerError('QueueIsNull');
        let currentSong = queue.songs[this.songNum];
        // Ends the dispatcher
        queue.dispatcher.end();
        queue.skipped = true;
        queue.backed = false
        queue.jump = {
            jumped: false,
            songNum: this.songNum
        }
        // Resolves the current song
        return currentSong;
    }

    /**
     * Skips a song back.
     * @param {string} guildID
     * @returns {Song}
     */
    back(guildID) {
        // Gets guild queue
        let queue = this.queues.find((g) => g.guildID === guildID);
        if (!queue) return new MusicPlayerError('QueueIsNull');
        let currentSong = queue.songs[this.songNum];

        if (this.songNum === 0) return {song: currentSong, backable: false};
        // Ends the dispatcher
        queue.dispatcher.end();
        queue.skipped = false;
        queue.backed = true;
        queue.jump = {
            jumped: false,
            songNum: this.songNum
        }
        // Resolves the current song
        return {song: currentSong, backable: true};
    }

    /**
     * Jumps to a song.
     * @param {string} guildID
     * @returns {Song}
     */
    jump(guildID,jumpNum) {
        // Gets guild queue
        let queue = this.queues.find((g) => g.guildID === guildID);
        if (!queue) return new MusicPlayerError('QueueIsNull');
        let currentSong = queue.songs[this.songNum];
        // Ends the dispatcher
        queue.dispatcher.end();
        queue.skipped = false;
        queue.backed = false;
        queue.jump = {
            jumped: true,
            songNum: jumpNum - 1
        }
        // Resolves the current song
        return currentSong;
    }

    /**
     * Gets the currently playing song.
     * @param {string} guildID
     * @returns {Song}
     */
    nowPlaying(guildID) {
        // Gets guild queue
        let queue = this.queues.find((g) => g.guildID === guildID);
        if (!queue) return new MusicPlayerError('QueueIsNull');
        let currentSong = queue.songs[this.songNum];
        // Resolves the current song

        return currentSong;
    }

    /**
     * Enable or disable the repeat mode
     * @param {string} guildID
     * @param {boolean} enabled Whether the repeat mode should be enabled
     * @returns {Void}
     */
    setRepeatMode(guildID, enabled) {
        // Gets guild queue
        let queue = this.queues.find((g) => g.guildID === guildID);
        if (!queue) return new MusicPlayerError('QueueIsNull');
        // Enable/Disable repeat mode
        queue.repeatMode = enabled;
        // Resolve
        return;
    }

    /**
     * Toggle the repeat mode
     * @param {string} guildID
     * @returns {boolean} Returns the current set state
     */
    toggleLoop(guildID) {
        // Gets guild queue
        let queue = this.queues.find((g) => g.guildID === guildID);
        if (!queue) return new MusicPlayerError('QueueIsNull');
        // Enable/Disable repeat mode
        queue.repeatMode = !queue.repeatMode;
        // Resolve
        return queue.repeatMode;
    }

    /**
     * Removes a song from the queue
     * @param {string} guildID 
     * @param {number} song The index of the song to remove or the song to remove object.
     * @returns {Song|MusicPlayerError}
     */
    remove(guildID, song) {
        // Gets guild queue
        let queue = this.queues.find((g) => g.guildID === guildID);
        if (!queue) return new MusicPlayerError('QueueIsNull');
        // Remove the song from the queue
        let songFound = null;
        if (typeof song === "number") {
            songFound = queue.songs[song];
            if (songFound) {
                queue.songs = queue.songs.filter((s) => s !== songFound);
            }
        } return new MusicPlayerError('NotANumber');
        // Resolve
        return songFound;
    }

    /**
     * Shuffles the guild queue.
     * @param {string} guildID 
     * @returns {Songs}
     */
    shuffle(guildID) {
        // Gets guild queue
        let queue = this.queues.find((g) => g.guildID === guildID);
        if (!queue) return new MusicPlayerError('QueueIsNull');

        let currentSong = queue.songs[this.songNum];
        queue.songs.splice(this.songNum,1);
        queue.songs = queue.songs.sort(() => Math.random() - 0.5);
        queue.songs.splice(this.songNum, 0, currentSong);

        return queue.songs;
    }


    /**
    * Creates a progress bar per current playing song.
    * @param {String} guildID Guild ID
    * @param {String} barSize Bar Size
    * @param {String} arrowIcon Arrow Icon
    * @param {String} loadedIcon Loaded Icon
    * @returns {String}
    */
    createProgressBar(guildID, barSize = 20, arrowIcon = '>', loadedIcon = '=') {
        let queue = this.queues.find((g) => g.guildID === guildID);
        if (!queue) return new MusicPlayerError('QueueIsNull');

        let timePassed = queue.dispatcher.streamTime  + queue.songs[this.songNum].seekTime;
        let timeEnd = Util.TimeToMilliseconds(queue.songs[this.songNum].duration);

        return `${Util.buildBar(timePassed, timeEnd, barSize, loadedIcon, arrowIcon)}`;
    }

    /**
     * Start playing songs in a guild.
     * @ignore
     * @param {string} guildID
     * @param {Boolean} firstPlay Whether the function was called from the play() one
     */
    async _playSong(guildID, firstPlay, seek = null) {
        // Gets guild queue
        let queue = this.queues.find((g) => g.guildID === guildID);
        // If there isn't any music in the queue
        if (this.songNum == queue.songs.length - 1 && !firstPlay && !queue.repeatMode && !queue.backed && !queue.jump.jumped) {
            // Emits stop event
            if (queue.stopped) {
                // Remoces the guild from the guilds list
                this.queues = this.queues.filter((g) => g.guildID !== guildID);

                if (this.options.leaveOnStop)
                    queue.connection.channel.leave();
                // Emits the stop event
                return queue.emit('stop');
            }
            // Emits end event
            if (this.options.leaveOnEnd) {
                // Emits the end event
                queue.emit('end');
                // Removes the guild from the guilds list
                this.queues = this.queues.filter((g) => g.guildID !== guildID);
                // Timeout
                let connectionChannel = queue.connection.channel;
                setTimeout(() => {
                    queue = this.queues.find((g) => g.guildID === guildID);
                    if (!queue || queue.songs.length < 1) {
                        return connectionChannel.leave();
                    }
                }, this.options.timeout);
                return;
            }
        }

        // Emit songChanged event
        if (!seek) {
            if (!firstPlay){
                if (!queue.jump.jumped) {
                    if (!queue.backed) {
                        this.songNum ++; 
                    } else { 
                        this.songNum --; 
                    }
                } else {
                    this.songNum = queue.jump.songNum;
                }
                queue.emit('songChanged', queue.songs[this.songNum], queue.songs[this.songNum], queue.skipped, queue.repeatMode);
            } else {
                this.songNum = 0;
            }
            localStorage.setItem('songNum', this.songNum);
        }   
        //declare all necessary vars to send message.
        const Discord = require('discord.js');
        const guild = this.client.guilds.cache.get(guildID);
        const id = JSON.parse(localStorage.getItem('textChannelID'));
        const TextChannel = guild.channels.cache.get(id);

        queue.skipped = false;
        queue.backed = false;
        queue.jump = {
            jumped: false,
            songNum: this.songNum
        }

        let song = await queue.songs[this.songNum];

        if (song === undefined) return;

        // Download the song
        let Quality = this.options.quality;
        Quality = Quality.toLowerCase() === 'low' ? 'lowestaudio' : 'highestaudio';

        const stream = ytdl(song.url, {
            filter: 'audioonly',
            quality: Quality,
            dlChunkSize: 0,
            highWaterMark: 1 << 25,
        }).on('error', err => {
            queue.emit('songError', (err.message === 'Video unavailable' ? 'VideoUnavailable' : err.message), queue.songs[this.songNum]);
            queue.repeatMode = false;
            return this._playSong(guildID, false);
        });
        
        if (queue.dispatcher) queue.dispatcher.destroy();
        let dispatcher = queue.connection.play(stream, {
            seek: seek / 1000 || 0,
        });
        queue.dispatcher = dispatcher;
        // Set volume
        dispatcher.setVolumeLogarithmic(queue.volume / 200);
        // When the song ends
        dispatcher.on('finish', () => {
            // Play the next song
            return this._playSong(guildID, false);
        });

        
        //deletes previous embed        
        try{
            playingMessageStack.map(async playingMsg => {
                if (await this.client.channels.cache.get(playingMsg.channel.id) !== undefined) {
                    if (await this.client.channels.cache.get(playingMsg.channel.id).messages.fetch(playingMsg.id) !== undefined) {
                        try {
                            await playingMsg.delete();
                        } catch (error) { console.error(error.name) }
                        console.log(playingMsg.deleted)
                        await playingMessageStack.shift();
                    }
                }

            });
        } catch (error) { console.log(error) }

        //sends now playing message
        try {
            if (queue.songs[this.songNum] !== undefined)
            setTimeout(async () => {
            await TextChannel.send(new Discord.MessageEmbed()
                .setDescription(`**Now playing...**\n"[${queue.songs[this.songNum].name}](${queue.songs[this.songNum].url})"\n*By ${queue.songs[this.songNum].author}*\n${this.createProgressBar(guild.id, 20, '\\🔘', '\\◽')}`)
                .setThumbnail(queue.songs[this.songNum].thumbnail)
                .setAuthor('Gamenight Music', 'https://i.imgur.com/XivpRjd.png'))
                .then(message => {
                    //saves playing message
                    playingMessageStack.push(message)
                });
            }, 100);
        } catch {}
    }

    
};

module.exports = Player;

