{"version":3,"file":"youtube-playlist-scraper.mjs","sources":["../src/build-playlist.ts","../src/utils.ts","../src/get-playlist-html.ts","../src/parse-initial-data.ts","../src/index.ts"],"sourcesContent":["import get from \"lodash.get\";\nimport { Playlist, Video } from \"./types\";\n\nexport const buildPlaylistVideos = (data: object): Video[] => {\n  const items = get(\n    data,\n    \"contents.twoColumnBrowseResultsRenderer.tabs[0].tabRenderer.content.sectionListRenderer.contents[0].itemSectionRenderer.contents[0].playlistVideoListRenderer.contents\"\n  );\n\n  return items.reduce((acc: Video[], item: any) => {\n    if (typeof item.playlistVideoRenderer === \"undefined\") return acc;\n    const body = item.playlistVideoRenderer;\n    const id = body.videoId;\n    return [\n      ...acc,\n      {\n        id,\n        name: get(body, \"title.runs[0].text\", \"\"),\n        url: `https://youtube.com/watch?v=${id}`,\n      },\n    ];\n  }, []);\n};\n\nexport const buildPlaylist = (data: object): Playlist => {\n  const maybeTitle = get(data, \"metadata.playlistMetadataRenderer.title\", \"\");\n  return {\n    title: maybeTitle.trim(),\n    playlist: buildPlaylistVideos(data),\n  };\n};\n","/**\n * Check whether something is an object\n * @param obj - Value to check\n */\nconst isObject = (obj: any): boolean => obj && typeof obj === \"object\";\n\n/**\n * Deeply merge two objects, merging the right-most down\n *\n * @export\n * @param {...object[]} objects\n * @returns\n */\nexport function mergeDeep(...objects: object[]) {\n  return objects.reduce(\n    (prev: Record<string, any>, obj: Record<string, any>) => {\n      const keys = Object.keys(obj);\n      for (let i = 0, len = keys.length; i < len; i++) {\n        const key = keys[i];\n        const pVal = prev[key];\n        const oVal = obj[key];\n        if (Array.isArray(pVal) && Array.isArray(oVal)) {\n          prev[key] = [...pVal, ...oVal];\n        } else if (isObject(pVal) && isObject(oVal)) {\n          prev[key] = mergeDeep(pVal, oVal);\n        } else {\n          prev[key] = oVal;\n        }\n      }\n      return prev;\n    },\n    {}\n  );\n}\n","import fetch, { RequestInit } from \"node-fetch\";\nimport { mergeDeep } from \"./utils\";\n\nconst getPlaylistUrl = (id: string): string =>\n  `https://www.youtube.com/playlist?list=${id}`;\n\nconst FETCH_DEFAULTS: RequestInit = {\n  headers: {\n    \"User-Agent\":\n      \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.67 Safari/537.36\",\n  },\n};\n/**\n * Fetch the HTML for the given playlist ID\n * @param playlistId - ID of playlist\n */\nexport async function getPlaylistHtml(\n  playlistId: string,\n  fetchOptions?: RequestInit\n): Promise<string> {\n  const options: RequestInit = mergeDeep(FETCH_DEFAULTS, fetchOptions || {});\n  const response = await fetch(getPlaylistUrl(playlistId), options);\n  const html = await response.text();\n  if (!response.ok) {\n    throw new Error(`Unable to fetch playlist with ID: ${playlistId}`);\n  }\n  return html;\n}\n","/**\n * Try and parse JSON\n * @param {*} str - JSON to parse\n */\nconst tryParseJson = (str: string): object => {\n  let data = null;\n  try {\n    data = JSON.parse(str);\n  } catch (e) {\n    console.log(e);\n  }\n  return data;\n};\n\n/**\n * Extract the YT Initial Data from the markup\n * @param html - HTML string\n */\nexport default function parseInitialData(html: string) {\n  if (!html || !html.length) return null;\n  var match = html.match(\n    /(?:window\\[(?:\"|')ytInitialData(?:\"|')\\]|var ytInitialData) = ([^\\n]+?); ?(?:<\\/script>|\\n)/\n  );\n  if (!match || !match[1]) return null;\n  return tryParseJson(match[1]) || null;\n}\n","import { RequestInit } from \"node-fetch\";\nimport { buildPlaylist } from \"./build-playlist\";\nimport { getPlaylistHtml } from \"./get-playlist-html\";\nimport parseData from \"./parse-initial-data\";\nimport { Playlist } from \"./types\";\nexport * from \"./types\";\n\n/**\n * Try and scrape the playlist for a given ID\n *\n * @param playlistId - ID of the playlist we wish to scrape\n */\nexport async function scrapePlaylist(\n  playlistId: string,\n  fetchOptions?: RequestInit\n): Promise<Playlist> {\n  const html = await getPlaylistHtml(playlistId, fetchOptions);\n  const data = parseData(html);\n  if (data === null) {\n    throw new Error(\"Unable to parse ytInitialData\");\n  }\n  try {\n    return buildPlaylist(data);\n  } catch (error) {\n    throw new Error(\"Unable to parse body\");\n  }\n}\n"],"names":["parseData"],"mappings":";;;MAGa,sBAAsB,CAAC;AAClC,QAAM,QAAQ,IACZ,MACA;AAGF,SAAO,MAAM,OAAO,CAAC,KAAc;AACjC,QAAI,OAAO,KAAK,0BAA0B;AAAa,aAAO;AAC9D,UAAM,OAAO,KAAK;AAClB,UAAM,KAAK,KAAK;AAChB,WAAO;AAAA,MACL,GAAG;AAAA,MACH;AAAA,QACE;AAAA,QACA,MAAM,IAAI,MAAM,sBAAsB;AAAA,QACtC,KAAK,+BAA+B;AAAA;AAAA;AAAA,KAGvC;AAAA;MAGQ,gBAAgB,CAAC;AAC5B,QAAM,aAAa,IAAI,MAAM,2CAA2C;AACxE,SAAO;AAAA,IACL,OAAO,WAAW;AAAA,IAClB,UAAU,oBAAoB;AAAA;AAAA;;ACxBlC,MAAM,WAAW,CAAC,QAAsB,OAAO,OAAO,QAAQ;sBASjC;AAC3B,SAAO,QAAQ,OACb,CAAC,MAA2B;AAC1B,UAAM,OAAO,OAAO,KAAK;AACzB,aAAS,IAAI,GAAG,MAAM,KAAK,QAAQ,IAAI,KAAK;AAC1C,YAAM,MAAM,KAAK;AACjB,YAAM,OAAO,KAAK;AAClB,YAAM,OAAO,IAAI;AACjB,UAAI,MAAM,QAAQ,SAAS,MAAM,QAAQ;AACvC,aAAK,OAAO,CAAC,GAAG,MAAM,GAAG;AAAA,iBAChB,SAAS,SAAS,SAAS;AACpC,aAAK,OAAO,UAAU,MAAM;AAAA;AAE5B,aAAK,OAAO;AAAA;AAAA;AAGhB,WAAO;AAAA,KAET;AAAA;;AC5BJ,MAAM,iBAAiB,CAAC,OACtB,yCAAyC;AAE3C,MAAM,iBAA8B;AAAA,EAClC,SAAS;AAAA,IACP,cACE;AAAA;AAAA;+BAQJ,YACA;AAEA,QAAM,UAAuB,UAAU,gBAAgB,gBAAgB;AACvE,QAAM,WAAW,MAAM,MAAM,eAAe,aAAa;AACzD,QAAM,OAAO,MAAM,SAAS;AAC5B,MAAI,CAAC,SAAS;AACZ,UAAM,IAAI,MAAM,qCAAqC;AAAA;AAEvD,SAAO;AAAA;;ACtBT,MAAM,eAAe,CAAC;AACpB,MAAI,OAAO;AACX;AACE,WAAO,KAAK,MAAM;AAAA,WACX;AACP,YAAQ,IAAI;AAAA;AAEd,SAAO;AAAA;0BAOgC;AACvC,MAAI,CAAC,QAAQ,CAAC,KAAK;AAAQ,WAAO;AAClC,MAAI,QAAQ,KAAK,MACf;AAEF,MAAI,CAAC,SAAS,CAAC,MAAM;AAAI,WAAO;AAChC,SAAO,aAAa,MAAM,OAAO;AAAA;;8BCXjC,YACA;AAEA,QAAM,OAAO,MAAM,gBAAgB,YAAY;AAC/C,QAAM,OAAOA,iBAAU;AACvB,MAAI,SAAS;AACX,UAAM,IAAI,MAAM;AAAA;AAElB;AACE,WAAO,cAAc;AAAA,WACd;AACP,UAAM,IAAI,MAAM;AAAA;AAAA;;;;"}